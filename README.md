# DDD
    DDD架构中，能明显看出越外层的代码越稳定，越内层的代码演进越快，真正体现了领域“驱动”的核心思想。
    DDD不是一个什么特殊的架构，而是任何传统代码经过合理的重构之后最终一定会抵达的终点。DDD的架构能够有效的解决传统架构中的问题：
       *高可维护性：当外部依赖变更时，内部代码只用变更跟外部对接的模块，其他业务逻辑不变。
       *高可扩展性：做新功能时，绝大部分的代码都能复用，仅需要增加核心业务逻辑即可。
       *高可测试性：每个拆分出来的模块都符合单一性原则，绝大部分不依赖框架，可以快速的单元测试，做到100%覆盖。
       *代码结构清晰：通过POM module可以解决模块间的依赖关系， 所有外接模块都可以单独独立成Jar包被复用。当团队形成规范后，可以快速的定位到相关代码。

# 四层架构：
    表现层（Interfaces）
    应用层（Application）
    领域层（Domain）
    基础设施层（Infrastructure）

# 【asm 采用4层架构 DDD版本 】

## Interfaces 对外服务层(展现层/协议转换) 最顶层
    通常叫【interfaces/web/controller/adapter】因未来前后端分离是主流，后端只负责提供接，因此这里叫【api】，
    该层包含与其他系统进行交互的接口与通信设施，在多数应用里，该层可能提供包括Web Services、RMI或Rest等在内的一种或多种通信接口。
    【* HTTP和RPC接口，返回值为Result，捕捉所有异常】

## application  应用层
    服务（Service） 负责协调和委派，并不实现业务逻辑
    数据传输对象 DTO（DataTransfer Object） 把内部的领域对与外部隔离
    转配（Assembler） 实现DTO与领域对象之间的互相转换，数据交互，几乎总是与DTO一起出现
    VO 视图层展示数据
    Converter  数据转换
    表面/门面（Facade）： 为远程客户端提供粗粒度的调用接口，他的作用就是将一个用户请求委派给一个或多个service进行处理(非必须)
## domain   领域模型层（DDD的核心层 几乎全部的业务逻辑都会在该层实现）
    实体（Entity ）：具有唯一标识的对象
    工厂(factories) :创建复杂对象，影藏创建细节
    Domain Event（领域事件）
    仓储（Repository）:提供查找和持久化对象的方法,  [有的地方也叫gateway这里区分微服务网关不这样叫]
    ablility： 一些无法归到实体对象或值对象上，本质是一些操作，而非事务
    Domain模块仅依赖Types模块，也是纯 POJO 。
    聚合/聚合根（aggregates,aggregate roots）：  聚合是指一组具有内聚关系的相关对象的集合，每个聚合都有一个 root 和 boundary
    防腐层（ACL） 有效的隔离外部依赖和内部逻辑，无论外部如何变更，内部代码可以尽可能的保持不变。
    中间件   
    说明: 对应各个服务内部通用的对象打包该组件 共用
## Infrastructure  基础实施层（最底层）
    向其他层提供通用的技术能力(比如工具类,第三方库类支持,常用基本配置,数据访问底层实现) 
    common      基础类库
    converter   数据转换
    domain      数据库对象
    mapper      数据库映射
    仓储（Repository）:提供查找和持久化对象的方法实现,   [有的地方也叫gateway这里区分微服务网关不这样叫]
    通用枚举、状态吗、异常、工具类 （各微服务之前通用的基础数据）

